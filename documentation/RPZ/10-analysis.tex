\section{Аналитический раздел}

В данном разделе формализуется задача, приводится требуемая функциональность разрабатываемого приложения, проводится анализ существующих решений.

\subsection{Формализация задачи}
Необходимо реализовать клиент-серверное приложение для доступа к базе данных, предназначенной для хранения информации о действиях и характеристиках, необходимых для определения усталости пользователей АРМ. Данная потребность связана с тем, что при работе с InfluxDB на ЯП Kotlin на текущий момент отсутствуют библиотеки, отвечающие полноте функционала, который может понадобится при проводимых работах.

В качестве решения поставленной задачи поставщики СУБД предлагают разработчику реализовать собственное серверное приложение, которое будет обрабатывать запросы, используя обращения к API развёрнутой СУБД.

К возможностям, которые должен предоставлять сервер, отнесены:
\begin{itemize}[leftmargin=1.6\parindent]
\item внесение данных;
\item получение данных;
\item проверка существования хранилища для пользователя;
\item создание хранилищ для новых пользователей.
\end{itemize}

\subsection{Существующие решения}
\subsubsection{The Kotlin InfluxDB 2.0 Client}
The Kotlin InfluxDB 2.0 Client \cite{influxClient} - это клиент, который предоставляет возможность производить запросы и запись в InfluxDB 2.0 с использованием ЯП Kotlin. Данная библиотека поддерживает асинхронные запросы с использованием Kotlin Coroutines.

На данный момент решение поддерживает следующий функционал:
\begin{itemize}[leftmargin=1.6\parindent]
\item запись в базу данных;
\item чтение базы данных с использованием стандартного языка InfluxQL;
\item чтение базы данных с использованием языка Flux.
\end{itemize}

Данным решением не поддерживается следующий требуемый функционал:
\begin{itemize}[leftmargin=1.6\parindent]
\item проверка существования хранилища для пользователя;
\item создание хранилищ для новых пользователей.
\end{itemize}

\subsubsection{InfluxDB v2 API}
InfluxDB поддерживает обращение к InfluxDB v2 API \cite{influxApi}. InfluxDB API предоставляет способ взаимодействия с базой данных с использованием HTTP-запросов и ответов, включающих в своё тело данные в формате JSON, HTTP аутентификации, а также с поддержкой токенов JWT и базовой аутентификации.

Предоставляемый данным интерфейсом функционал полон и непосредственно используется в реализации Web-клиента данной СУБД. К недостатку использования данного метода взаимодействия относятся формирование множественных HTTP-запросов и потребность в обработке ответов.

\subsubsection*{Вывод}
Среди рассмотренных существующих решений отсутствуют примеры удобной реализации, отвечающей полноте функционала, которую можно было бы использовать при написании приложений на ЯП Kotlin.

\subsection{Архитектура клиент-сервер}
Программное обеспечение архитектуры "клиент-сервер" состоит из двух частей: программного обеспечения сервера и программного обеспечения пользователя -- клиента. Программа-клиент выполняется на компьютере пользователя и посылает запросы к программе-серверу, которая работает на компьютере общего доступа. Основная обработка данных производится мощным сервером, а на компьютер пользователя возвращаются только результаты выполнения запроса. В такой архитектуре сервер называется сервером баз данных. \cite{clientServer}

Иными словами, данная архитектура определяет общие принципы организации взаимодействия в сети, где имеются серверы, узлы-поставщики некоторых специфичных функций, и клиенты, потребители данных функций.

Каждое приложение, опирающееся на архитектуру "клиент-сервер", определяет собственные или использует имеющиеся правила взаимодействия между клиентами и сервером, которые называются протоколом обмена или протоколом взаимодействия. \cite{clientServerProt}

\subsection{Шаблон проектирования Model-View-Controller}
Шаблон проектирования MVC предполагает разделение данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер, что приводит к возможности модификации каждого из упомянутых компонентов независимо друг от друга. \cite{mvcInfo}

Model предоставляет данные предметной области представлению и реагирует на команды контроллера, изменяя свое состояние. В это премя View отвечает за отображение данных предментной области (модели) пользователю, реагируя на изменения модели. Controller интерпретирует действия пользователя, оповещая модель о необходимости изменений. \cite{mvcInfo}

Модель обладает следующими признаками \cite{mvcHabr}:
\begin{itemize}[leftmargin=1.6\parindent]
\item содержание бизнес-логики приложения;
\item отсутствие связей с контроллером и представлением;
\item представляет собой слой данных, менеджер базы данных или набор объектов.
\end{itemize}

Представление обладает следующими признаками \cite{mvcHabr}:
\begin{itemize}[leftmargin=1.6\parindent]
\item включает в себя реализацию отображения данных, которые получаются от модели любым способом;
\item в некоторых случаях может включать в себя реализацию некоторой бизнес-логики.
\end{itemize}

Контроллер обладает следующими признаками \cite{mvcHabr}:
\begin{itemize}[leftmargin=1.6\parindent]
\item объект определяет, какое представление должно быть отображено в данный момент;
\item зависим от событий представления.
\end{itemize}

Таким образом, для проектируемого программного обеспечения можно определить, что при использовании паттерна проектирования MVC, в качестве модели будут использоваться компоненты доступа к данным. Сервер будет использовать контроллеры для получения необходимой клиенту информации, причём представление будет определяться пользователем удалённо, так как предоставляемый сервис не предусматривает пользовательского интерфейса для взаимодействия с конкретными функциями.

\subsection{Протокол HTTP}
Протокол HTTP реализует клиент-серверную технологию, которая предполагает наличие множества клиентов, инициирующих соединение и посылающих запрос, а также множества серверов, получающих запросы, выполняющих требуемые действия и возвращающих клиентам результат. \cite{http}

В данном протоколе главным объектом обработки является ресурс, который в клиентском запросе записан в URI (Uniform Resource Identifier). В качестве ресурса выступают файлы, хранящиеся на сервере. HTTP позволяет определить в запросе и ответе способ представления ресурса по различным параметрам. \cite{http}

К преимуществам протокола HTTP относят \cite{http}:
\begin{itemize}[leftmargin=1.6\parindent]
\item простоту;
\item расширяемость;
\item распространённость;
\item документация на различных языках.
\end{itemize}

К недостаткам данного протокола относят \cite{http}:
\begin{itemize}[leftmargin=1.6\parindent]
\item отсутствие "навигации";
\item отсутствие поддержки распределенных действий.
\end{itemize}

Каждое HTTP-сообщение состоит из трех частей \cite{http11}:
\begin{itemize}[leftmargin=1.6\parindent]
\item стартовой строки (определяющей тип сообщения);
\item заголовков (характеризующих тело сообщения, параметры передачи и т.д.);
\item тела (данные сообщения).
\end{itemize}

Версия протокола 1.1 включает в себя требование наличия заголовка Host. Сами заголовки представляют собой строки, содержащие разделенную двоеточием пару параметра и значения. \cite{http11}

Стартовая строка запроса включает в себя \cite{http11}:
\begin{itemize}[leftmargin=1.6\parindent]
\item метод (тип запроса, одно слово заглавными буквами);
\item путь к запрашиваемому ресурсу;
\item версию используемого протокола.
\end{itemize}

Метод указывает на основную операцию над ресурсом. Среди наиболее часто используемых методов можно выделить \cite{http11}:
\begin{itemize}[leftmargin=1.6\parindent]
\item GET -- запрос содержимого указанного ресурса;
\item POST -- передача пользовательских данных заданному ресурсу;
\item PUT -- загрузка содержимого запроса по указанному пути;
\item PATCH -- PUT, применимый к фрагменту ресурса;
\item DELETE -- удаление указанного ресурса.
\end{itemize}

В качестве ответа клиенту сервер также направляет код состояния, по которому тот узнает о результатах выполнения запроса. Выделяют 5 классов состояний \cite{http11}:
\begin{itemize}[leftmargin=1.6\parindent]
\item 1xx -- информационный (информирование о процессе передачи);
\item 2xx -- успех (информирование о случаях успешного принятия и обработки запроса);
\item 3xx -- перенаправление (сообщение о том, что для успешного выполнения операции потребуется выполнить другой запрос);
\item 4xx -- ошибка клиента (указание на ошибки со стороны клиента);
\item 5xx -- ошибка сервера (информирование о неудачном выполнении операции на стороне сервера).
\end{itemize}


\subsubsection*{Вывод}
В разделе была предоставлена формализация задачи: реализация клиент-серверного приложения для доступа к базе данных InfluxDB с предоставлением возможности внесения и получения данных, проверки существования хранилища для пользователя и создания хранилищ для новых пользователей.
Была предоставлена информация о существующих решениях, которые могут использоваться при решении задачи. Сделаны выводы о том, что среди рассмотренных продуктов отсутствуют примеры удобной в использовании реализации, отвечающей полноте функционала.
Также было предоставлено определение понятия "клиент-серверного" приложения и приведена информация о наиболее часто используемом протоколе взаимодействия, используемого в подобных приложениях.


\pagebreak